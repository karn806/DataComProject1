#!/usr/bin/env python
import asyncore, socket
import logging
from cStringIO import StringIO ## StringIO append is faster than the normal one
import os
import sys
from urlparse import urlparse
import socket as sk

def mkHeaderRequest(serv, objName):
	return ("HEAD {o} HTTP/1.1\r\n" + "Host: {s}\r\n"+ "Cennection: close\r\n" + "\r\n\r\n").format(o=objName, s=serv)

# def rangeBytesRequest(serv, objName, sizeFile, end_point):
	# return ("GET {o} HTTP/1.1\r\n" + "Host: {s}\r\n" + "Cennection: close\r\n" + "Range: bytes={r}-{e}" + "\r\n\r\n").format(o=objName, s=serv, r=str(sizeFile), e=str(end_point))

# def mkDownloadRequest(serv, objName, sizeFile, end_point):
# 	return ("GET {o} HTTP/1.1\r\n" + "Host: {s}\r\n" + "Range: bytes={r}-{e}" + "\r\n\r\n").format(o=objName, s=serv, r=str(sizeFile), e=str(end_point))

path = sys.argv[5]
url = urlparse(path)
servName = str(url[1])
object_ = str(url[2])
port = url.port
if port==None:
	port = 80

inputName = sys.argv[2]
cennection_num = sys.argv[4]


input_header = inputName+"_header.txt"
keep = ""

def getHeaderOnly(servName, port):

	## create an empty socket
	sock = sk.socket(sk.AF_INET, sk.SOCK_STREAM)
	## connect to a destination as specified by the pair
	sock.connect((servName, port))

	request = mkHeaderRequest(servName, path)
	sock.send(request)

	header = sock.recv(1024)

	return header

def make_request(req_type, what, details, sizeFile, end_point, version="1.1"): ## GET/HEAD , path , host, ver
    """ Compose an HTTP request """
    NL = "\r\n"
    request_line = "{req_type} {what} HTTP/{ver}".format(
        req_type=req_type,
        what=what,
        ver=version
    )
 
    detail_lines = NL.join("{}: {}".format(name, value) for name, value in details.iteritems())

    Range_request = "Range: bytes={r}-{e}".format(r=str(sizeFile), e=str(end_point))
 
    full_request = request_line + NL + detail_lines + NL + Range_request + NL + NL
    return full_request



### helper function to separate the header and some first chunk of body content
def getHeader_theRest(input_data): ## input data
	if "\r\n\r\n" in input_data:
		# print "enter rnrn"
		find_index_rn = input_data.find("\r\n\r\n")
		header = input_data[:find_index_rn+3] ## start to end of header
		therest = input_data[find_index_rn+4:] ## the first few chunk of body
		# print "header = ", header
		return header, therest

def getContentLength(header):
	index = header.find("Content-Length: ")
	ContentLength = header[index:]
	indexColon = ContentLength.find(":")
	numContentLength = ContentLength[indexColon+2:]
	findBackrn = numContentLength.find("\r\n")
	pureContentLength = numContentLength[:findBackrn]

	return pureContentLength


def findContentLength(file_header):
	ContentLength = ""
	header = open(file_header, "r")
	for each_line in header:
		if "Content-Length:" in each_line:
			indexColon = each_line.find(":")
			ContentLength = each_line[indexColon+2:]
			break
	header.close()
	return int(ContentLength)

def findETag(file_header):
	etag = ""
	header = open(file_header, "r")
	for each_line in header:
		if "ETag:" in each_line:
			indexColon = each_line.find(":")
			etag = each_line[indexColon+2:]
			break
	header.close()
	return etag

def findDateModified(file_header):
	dm = ""
	header = open(file_header, "r")
	for each_line in header:
		if "Last-Modified:" in each_line:
			indexColon = each_line.find(":")
			dm = each_line[indexColon+2:]
			break
	header.close()
	return dm

class HTTPClient(asyncore.dispatcher): ## inherit - extend in python style

	def __init__(self, host, path, port, sizeFile, end_point): #header_check
		asyncore.dispatcher.__init__(self)	## super -- call structure of super class , self is itself object
		self.create_socket(socket.AF_INET, socket.SOCK_STREAM)
		self.connect((host, port))
		# self.header_check = True
		self.host = host
		self.length = 0
		self.header_check = 1
		self.recvbuf = StringIO()  ## it's like string builder
		self.logger = logging.getLogger(host+path)

		self.sendbuf = ""
		# # make my request_line
		self.write(
			make_request('GET', path, {"host": host, "Connection": "close"}, 0, "") ## Non-persistent connection
			)


		# self.write(mkDownloadRequest(host, path, sizeFile, end_point))

	def write(self, msg):
		self.sendbuf += msg


	def handle_connect(self):
		print "Connection established"
		# self.logger.debug("connection established")


	def handle_close(self):
		# self.logger.debug("got disconnected")
		print "Got disconnected"
		print "Download done."
		self.close()


	def handle_read(self): 
		data = self.recv(1024)
		print len(data)
		body = open(inputName, "a+")
		if self.header_check == 1:
			header, therest = getHeader_theRest(data)
			keep_header = open(input_header, "a+")
			keep_header.write(header)
			keep_header.flush()
			keep_header.close()
			# print header, '--------'
			body.write(therest)
			# print "body.write"
			body.flush()
			# print "body.flush"
			if header!="":
				self.header_check = 0
		else:
			# if len(data) == 0:
			# 	self.close()
			body.write(data)
			body.flush()


		
	def writeable(self): # if there is anything to send??
		return len(self.sendbuf) > 0 ## you have sth to send


	def handle_write(self):
		bytes_send = self.send(self.sendbuf)
		self.sendbuf = self.sendbuf[bytes_send:] ## the remainder


HTTPClient(servName, object_, port, 0, "")
# http://images.clipartpanda.com/lion-clipart-4Tb5XEETg.png
# clients = [ ## simultineously download
# 	HTTPClient("www.nytimes.com", "/") ,
# 	HTTPClient("www.chula.ac.th", "/") ,
# 	HTTPClient("www.cnn.com", "/") ,
# 	HTTPClient("www.wsj.com", "/")
# ]

logging.basicConfig(level=logging.DEBUG,
    format="%(asctime)-15s %(name)s: %(message)s"
    )
 
asyncore.loop()
