#!/usr/bin/env python

# create socket
# bind socket
# connect socket
# send request

# open file
# get each piece of info from socket
# write each oiece of info into file
# when done
# readfile and cur off header


import socket as sk 
import os
import sys
from urlparse import urlparse



def srget():
	inputName = sys.argv[2]
	url = sys.argv[3]
	urlLast = urlparse(url)
	scheme = urlLast[0]
	servName = urlLast[1]
	path = urlLast[2]
	port = urlLast.port
	if scheme == 'https':
		sys.exit(1)
	if port==None:
		port = 80
	# objName = url[2]
		



	def mkDownloadRequest(serv, objName):
		return ("GET {o} HTTP/1.1\r\n" + "Host: {s}"+"\r\n\r\n").format(o=objName, s=serv)

	def rangeBytesRequest(serv, objName, sizeFile):
		# sizeFile = os.path.getsize(file_)
		return ("GET {o} HTTP/1.1\r\n" + "Host: {s}\r\n" + "Range: bytes={r}" + "\r\n\r\n").format(o=objName, s=serv, r=str(sizeFile))

	#print "{!r}".format(mkDownloadRequest("intranet.mahidol", "/"))

	# servName = "intranet.mahidol"
	# port = 80


	## create an empty socket
	sock = sk.socket(sk.AF_INET, sk.SOCK_STREAM)
	## connect to a destination as specified by the pair
	sock.connect((servName, port))

	request = mkDownloadRequest(servName, path)
	sock.send(request)



	# if os.path.exists(inputName):
	# # 	## is it modified yet?
	# # 		## if yes, then check if the content is complete or not?
	# # 		## if not, 	
	# else:
	# 	## create an empty socket
	# 	sock = sk.socket(sk.AF_INET, sk.SOCK_STREAM)
	# 	## connect to a destination as specified by the pair
	# 	sock.connect((servName, port))

	# 	request = mkDownloadRequest(servName, path)
	# 	sock.send(request)






	def getHeader(socket_input):
		content = ''
		while True:
			chunk = sock.recv(1024)
			content+=chunk
			if "\r\n\r\n" in content:
				findrnrnIndex = content.find('\r\n\r\n')
				header = content[:findrnrnIndex+4] ## start to end of header
				therest = content[findrnrnIndex+4:] ## the firse few chunk of header
				break
		return header, therest #header, therest
	# print getHeader(sock)

	def getContentLength(header):
		# print header
		index = header.find("Content-Length: ")
		# print index
		ContentLength = header[index:]
		#print ContentLength
		indexColon = ContentLength.find(":")
		numContentLength = ContentLength[indexColon+2:]
		# print numContentLength
		findBackrn = numContentLength.find("\r\n")
		pureContentLength = numContentLength[:findBackrn]

		return pureContentLength
	# print getContentLength(sock)

	# def getDateModified(header):
	# 	###


	def get_body(socket_input):
		# header, body = getHeader(socket_input) ## get the rest from tuple(header, therest)
		# ContentLength = getContentLength(header) ## type == str
		if os.path.exists(inputName):
			header, body = getHeader(socket_input) ## get the rest from tuple(header, therest)
			ContentLength = getContentLength(header) ## type == str
			print 'hi'
			print len(body)
			## check size of the file
			sizeFile = os.path.getsize(inputName)
			if sizeFile != ContentLength:
				# sock.close()

				## create socket again
				sock2 = sk.socket(sk.AF_INET, sk.SOCK_STREAM)
				## connect to a destination as specified by the pair
				sock2.connect((servName, port))

				request = rangeBytesRequest(servName, path, sizeFile)
				sock2.send(request)

				File = open(inputName, 'a+') # append
				File.write(body)
				File.flush()
				while True:
					if len(body) == int(ContentLength):
						print ContentLength, '----here!!'
						File.close()
						break
					chunk = sock.recv(1024)
					body += chunk
					File.write(chunk)
					File.flush()
		else:

			header, body = getHeader(socket_input) ## get the rest from tuple(header, therest)
			ContentLength = getContentLength(header) ## type == str
			File = open(inputName, 'a+') # append
			File.write(body)
			File.flush()
			while True:
				if len(body) == int(ContentLength):
					File.close()
					break
				chunk = sock.recv(1024)
				body += chunk
				File.write(chunk)
				File.flush()


	get_body(sock)

srget()














